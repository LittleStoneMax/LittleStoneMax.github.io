[{"content":"数据库基础 char和varchar的区别 char varchar 最大长度255字符 最大长度是65535个字节 定长不足的部分用隐藏空格填充 varchar是不定长的 char会浪费时间 varchar会节省空间 char查找效率高 varchar查找效率低 插入时可省略尾部空格 varchar插入时不会省略，查找时会省略 varchar(10) 和 varchar(20) 的区别 如果是存储相同长度的字符串，所占空间一样，如果涉及order by排序相关，后者消耗更多内存空间\ndrop、delete与truncate的区别 drop delete truncate 删除表结构和数据 删除表中数据 删除表中所有数据 DDL DML DDL 速度最快 最慢 其次 不可回滚 可回滚 不可回滚 UNION与UNION ALL的区别 UNION UNION ALL 将不同的记录返回到单个结果集中 将所有记录返回到单个结果集中 性能慢 性能快 消除重复行 不消除重复行 MySQL 的内连接、左连接、右连接有什么区别 内连接：根据连接条件从多个表中查询选择数据，显示这些表中与连接条件相匹配的行，组成新的记录 分为：等值连接（连接条件为相等判断）非等值连接（连接条件为不相等判断）自连接（在一个连接查询中，涉及的两个表都是同一张表的查询，相互连接的表在物理上为同一张表，在逻辑上分为两张表） 左外连接：left[outer] join 显示左表全部记录，右表满足连接条件的记录 右外连接：right[outer] join 显示右表全部记录，左表满足连接条件的记录\n常见的聚合函数有哪些使用聚合函数需要注意什么 avg 返回某列的平均值 sum 返回某列值的和 count 返回某列的行数 max 返回某列的最大值 min 返回某列的最小值 注意：聚合函数会自动忽略空值，不需要手动增加条件排除NULL 聚合函数不能作为where字句后的限制条件\n请说下你对 MySQL架构的了解 server层：连接器，查询缓存，分析器，优化器，执行器\n连接器：MYSQL基于TCP协议进行传输，连接过程需要经过TCP三次握手 存储引擎：InnoDB\n一条 SQL 语句在数据库框架中的执行流程 连接器：建立连接，管理连接、校验用户身份； 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块； 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型； 执行 SQL：执行 SQL 共有三个阶段： 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划； 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端； ![[Pasted image 20231224193353.png]]\n连接器：连接器连接客户端，MySQL基于TCP协议进行传输，所以要先经过TCP三次握手，连接完成建立后，判断用户密码，获取用户权限并保存，后续操作都基于连接时保存的权限进行权限逻辑的判断 查询缓存：MySQL收到SQL语句后，会解析出第一个字段，查看是什么类型的语句，如果是查询语句（select字段），MySQL会先去查询缓存（QueryCache）里查找缓存数据，查看之前是否有执行过这一条命令，查询缓存以key-value形式保存在内存中，key为SQL查询语句,value为SQL语句查询的结果，如果查询的语句命中缓存就会直接返回value给客户端，如果没命中就要继续执行，等执行完后查询的结果就会被存入查询缓存中，对于更新频繁的表，查询缓存的命中率很低，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空，如果刚缓存了一个查询结果很大数据，还没被使用这个表就更新了，那查询缓存就被清空了，所以MySQL8.0将查询缓存删除了 解析器： 词法分析：MySQL根据出入的字符串识别出关键字 语法分析：根据词法分析的结果，语法解析器会根据语法规则判断SQL语句是否满足MySQL语法，语法不对就报错，如果没问题就构建出SQL语法树，这样方便后续获取SQL类型、表名、字段名、where条件等 执行SQL： 每条select语句流程主要分三个阶段 预处理阶段： 检查SQL查询语句中的表或字段是否存在 将select *中的*符号扩展为表上的所有列 优化阶段：优化器负责确定SQL查询语句的执行方案，当表中有多个索引时，优化器基于成本考虑决定使用哪个索引，在查询语句钱加explain命令，就会输出这条SQL语句的执行计划，其中的key就表示会使用哪个索引，若Key为null说明没有使用索引，会全表扫描，这种查询方式效率最低 执行阶段：MySQL的执行器开始执行语句，在执行过程中会与存储引擎交互，交互以记录为单位，有三种执行方式：主键索引引擎，全表扫描，索引下推 数据库的三范式是什么 第一范式：属性具有原子性不可再分解，对关系型数据库的基本要求，通过分字段实现 第二范式：唯一性和依赖性，每个表都有主键，其他字段依赖主键，通过分表实现 第三范式：直接依赖，只依赖于主键，通过分表实现\n什么是范式和反范式，以及各自优缺点 范式：规范化的设计数据库 优点：可以减少数据冗余 数据表更新快体积小 缺点：多表联合查询，导致性能降低更难进行索引优化 反范式：增加字段，允许冗余，以空间换时间 优点：可以减少表的关联可以更好地进行索引优化 缺点：存在数据冗余及数据维护异常 对数据的修改需要更多成本\nlimit 1000000,10加载很慢，怎么解决 检查业务需求是否合理 id自增时可以从id\u0026gt;1000000开始查询 增加索引\n一条SQL查询语句的执行顺序 书写顺序：select distinct from join on where group by having order by limit 执行顺序：from join on where group by select distinct having order by limit\n存储过程和自定义函数 存储过程：一组预编译的SQL语句和流程控制语句，被命名并存储在数据库中。存储过 程可以用来封装复杂的数据库操作逻辑，并在需要时进行调用。\n#创建存储过程 create procedure 存储过程名() begin -- 存储过程的逻辑代码 -- 可以包含SQL语句、控制结构和变量操作等 end; #执行存储过程 call 存储过程名(); #删除存储过程 drop procedure [if exists] 存储过程名; create procedure mypro() begin select * from emp; select * from dept; end; call mypro(); drop procedure if exists mypro; //使用参数 create procedure 存储过程名( [in|out|inout] 参数名1 参数的数据类型, [in|out|inout] 参数名2 参数的数据类型, ) begin -- 存储过程的逻辑代码 -- 可以包含SQL语句、控制结构和变量操作等 end; 参数类型： in：输入参数，存储过程的输入值，从外部传递给存储过程，存储过程内部是只读的，不能修改它的值 out：输出参数，存储过程的返回值，存储过程可以修改它的值并将其返回 inout：输入和输出参数既可以作为输入值传递给存储过程，也可以由存储过程修改并返回 优点：\n代码复用：存储过程可以被多个应用程序或脚本调用，实现了代码的复用 提高性能：MySQL将编译后的存储过程放入缓存中，如果应用程序在单个连接中多次使用存储过程，直接使用编译版本 减少网络流量：存储过程可以一次执行多条SQL语句，减少了与数据库的交互次数 安全控制：存储过程可以对数据库中的数据进行严格的访问控制和权限管理 数据一致性：存储过程可以实现复杂的数据操作和事务处理，确保数据的一致性和完整性 缺点：\n创建和维护成本高：SQL是一种结构化查询语言，难以处理复杂的业务逻辑 开发调试复杂：需要通过特定的工具和技术进行，不方便调试 可移植性差：存储过程通常依赖于特定的数据库平台和版本，不同的数据库系统之间存储过程的语法和特性可能有差异，导致存储过程的可移植性差 自定义函数\n#创建函数 create function 函数名([参数1 数据类型 [, 参数2 数据类型, ...]]) returns 返回值类型 begin 函数逻辑代码 end; #调用函数 select 函数名([参数1, 参数2...]); #删除函数 drop function [if exists] 函数名; 游标 cursor,使用游标可以对存储过程或函数中的查询结果进行逐行处理 创建游标后，可以使用open语句打开游标，开始执行游标指定的查询语句并生成结果集。在游标打开得到结果集后，可以使用fetch语句访问它的每一行 游标处理完后，应关闭游标，释放游标使用的内存和资源\n#创建游标 declare 游标名 cursor for 查询语句; #打开游标 open 游标名; #读取游标数据到变量中 fetch 游标名 into 变量名1[,变量名2...]; #关闭游标 close 游标名; 触发器 trigger,在表的插入(insert) 、更新(update)、删除(delete)操作发生时自动执行MySQL语句 创建触发器时需要给出的信息：\n触发器名 在操作前还是操作后触发(before/after) 被什么操作触发(insert/update/delete) 关联的表 使用触发操作的数据： insert：可通过new访问被插入的行，before insert可以更新new中的值（允许更改被插入的值） delete：可通过old访问被删除的行,old中的值是只读的 update：old访问更新前的值，new访问更新后的值\n事务 如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功；如果其中由一条执行失败，那么所有已经执行过的代码必须回滚（撤销），回到没有执行前的状态，称为事务。简单来说，就是要么所有的SQL语句全部执行成功，要么全部失败\n事务的四大特性 事务特性 含义 原子性 事务是工作的最小单元,整个工作单元要么全部执行成功，要么全部执行失败 一致性 事务执行前和执行后，数据库中数据应该保持相同状态（数据总量不变） 隔离性 事务与事务之间不能互相影响，必须保持隔离性 持久性 如果事务执行成功，对数据库的操作是持久的redolog 事务提交的方式 自动提交：MySQL就是自动提交的（一条DML(增删改)语句会自动提交一次事务） 手动提交：需要先开启事务，再提交（Oracle是默认手动提交的） 查看事务的默认提交方式：select@@autocommit；(1代表自动提交，默认值，0代表手动提交) 修改默认提交方式：set@@autocommit = 0；(1代表自动提交，0代表手动提交) 事务的隔离级别 在 SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低\n未提交读：事务中的修改，没有提交也能被其他事务看到，这个级别导致很多问题，性能也没好太多，很少使用 提交读：事务中的修改提交后才能被看到，也被称为不可重复，因为两次执行同样的查询，可能得到不同的结果 可重复读：同一事务中多次读取同样记录的结果是一致的，该级别无法解决幻读问题，该级别是MySQL的默认隔离级别，并且MySQL的默认隔离级别，并且MySQL在该级别就可以很大程度上避免幻读 可串行化(序列化)：强制事务串行执行，避免幻读问题，该级别会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题的，很少使用这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下才考虑采用这个级别 #查看会话级的当前隔离级别：（会话级只对当前窗口有效） select @@tx_isolation; select @@session.tx_isolation; #查看全局级的当前隔离级别： select @@global.tx_isolation; 隔离级别 脏读 不可重复读 幻读 未提交读 Y Y Y 已提交读 X Y Y 可重复读 X X Y 可串行化 X X X 索引 哪些工作表需要创建索引 通常情况下，以下类型的工作表需要创建索引：\n数据量较大的表：数据量较大的表查询效率较低，需要创建索引来提高查询速度。 经常被查询的表：经常被查询的表需要创建索引来加速查询操作。 进行连接操作的表：进行连接操作的表需要创建索引来提高连接效率 索引的分类 分类方式 索引 数据结构 B+树索引、哈希索引、全文索引 物理存储 聚簇索引（主键索引）、二级索引（辅助索引） 字段特性 主键索引、唯一索引、普通索引、前缀索引 字段个数 索引的设计原则 为常作为查询条件的字段建立索引：如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度 为经常需要排序、分组和联合操作的字段建立索引：经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作 创建唯一性索引：唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录 限制索引的数目：每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。 小表不建议索引（如数量级在百万以内）：由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果 尽量使用前缀索引：如果索引的值很长，那么查询的速度会受到影响 删除不再使用或者很少使用的索引 聚簇索引 聚簇索引（一级索引），一种数据存储方式，将数据放在索引的叶子页，索引和数据在同一个 B+ 树上。因为无法同时把数据放在两个地方，所以一个表只有一个聚簇索引 在 InnoDB 中，这个索引是主键，如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替，也没有的话 InnoDB 会隐式定义一个主键作为聚簇索引 优点： 可以把相关数据保存在一起 数据访问更快，索引和数据在同一个结构中 缺点： 插入速度严重依赖插入顺序 更新聚簇索引引列的代价高 插入数据或更新主键时可能面临‘页分裂’问题，当主键值要求将该行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面放该行，会导致表占用更多的磁盘空间 非聚簇索引需要两次索引查找\n覆盖索引 也叫索引覆盖，查询所需要的数据都可以从索引中获取，而不用再去查询数据表中的实际数据，那么这个索引就是个覆盖索引 覆盖索引可以减少树的搜索次数，避免了回表，显著提升了查询性能\ncreate index ename_job on emp(ename,job); explain select ename,job from emp; 索引失效 查询条件包含or，or的前后不都是索引 使用like查询，%在前面且没有覆盖索引 对索引列使用函数 索引列使用运算 索引列使用不等于（\u0026lt;\u0026gt; ! = not in） 出现隐式类型转换，如字符型索引使用数字匹配 联合索引没有使用最左匹配 全表扫描比索引快（数据量少时） 最左前缀原则 创建多列的联合索引时，满足最左前缀原则，例如创建(a,b,c)三列的索引，实际上相当于创建了 a、(a, b)、(a,b,c)三个索引 当不需要考虑排序和分组时，将选择性最高的列放在前面。这时索引的作用只用于优化 where 条件的查找，这样设计可以最快过滤需要的行。\ncreate index ename_job_sal on emp(ename,job,sal); explain select * from emp where ename=\u0026#34;smith\u0026#34;; explain select * from emp where ename=\u0026#34;smith\u0026#34;and job=\u0026#34;manager\u0026#34;; explain select * from emp where job=\u0026#34;manager\u0026#34;;//不符合 优化索引（使用策略） 使用前缀索引 使用前缀索引可以节约索引空间，提高索引效率，但需要平衡索引的选择性\n联合索引 使用联合索引可以避免回表，实现覆盖索引，可以减少大量I/O操作，创建联合索引时，不同的列顺序会影响索引的性能，通常将选择性高的列放在最前面\n合适的主键索引 最好选择不会修改的列作为主键，不考虑分库分表的情况下最好使用自增主键\n不建立重复或不使用的索引 防止索引失效 当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx% 这两种方式都会造成索引失效； 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效； 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 其他 InnoDB 和 MyISAM 的比较 事务:MylSAM不支持事务，InnoDB支持事务 全文索引: MylSAM支持全文索引，InnoDB 5.6之前不支持全文索引 关于count(): MylSAM会直接存储总行数，InnoDB则不会，需要按行扫描。意思就是对于select count(from table;如果数据量大，MylSAM会瞬间返回，而InnoDB则会一行行扫描 外键:MylSAM不支持外键，InnoDB支持外键 锁: MyISAM只支持表锁，InnoDB可以支持行锁。 怎么优化MySQL ![[Pasted image 20231218192406.png]]\nB树和B+树 平衡二叉树随着节点的增加，树的高度会越来越高，会增加磁盘的I/O次数，影响查询效率，从而引出了B树，B树不限制一个节点只能有2个子节点，从而降低树的高度。B树可以将节点的大小优化为磁盘块的大小，每次读取可以有效加载多个节点，B树常用于数据库库等需要高效访问磁盘的场景，B+树是对B树的升级，B+树只有叶子节点存数据，非叶子节点只存索引。叶子节点包含所有索引，叶子节点构成一个有序链表，范围查找更快，由于非叶子节点只存索引，B+树比B树的非叶子节点可以存更多索引，高度更低，磁盘I/O次数更少 ![[Pasted image 20231214192001.png]]\nB+树和跳表的区别 #待更新。。\n","permalink":"https://littlestonemax.github.io/posts/tech/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"数据库基础 char和varchar的区别 char varchar 最大长度255字符 最大长度是65535个字节 定长不足的部分用隐藏空格填充 varchar是不定长的 char会浪费时间 varchar会节省空间 char查找效率高 varchar查找效率低 插入时可省略尾部空格 varchar插入时不会省略，查找时","title":"Mysql数据库"},{"content":"基础 引用和指针的区别 引用在定义时必须被初始化并且不能被初始化为NULL，指针没有要求 引用不能改变引用关系（底层用指针常量实现），指针随意 有多级指针没有多级引用 自增自减表达的含义不同。指针自加即指针向后偏移一个类型的大小，引用自增即引用的实体自加 指针用sizeof计算大小结果不同，指针在32位内存下是4字节，在64位内存下是8字节，引用结果为类型大小 指针是一个实体，需要分配空间；引用是变量的别名，不需要分配内存空间 访问实体的方式不同，指针需要显示解引用，引用编译器自己处理 在语法概念上,引用就是一个别名,没有独立空间,和其引用实体共用同一块空间.但是在底层实现上实际是有空间的,因为引用是按照指针方式来实现的\nmalloc free和new delete的区别 malloc和free是c语言中的库函数 new和delete是c++中操作符 new自动计算所需分配内存大小 malloc需要手动计算 new返回的是对象类型的指针 malloc返回的是void*之后进行类型转换 new分配失败会抛出异常 malloc分配失败返回的是NULL new是在freestore（自由存储区）上分配内存 malloc通常在堆上分配 delete需要对象类型的指针 free是void*类型的指针 malloc分配的是虚拟内存不一定有物理内存 若小于128k分配在堆上若大于128k分配在文件映射区\nnew 1 operator new 2 申请足够的空间 3 调用构造函数初始化成员变量 delete 1 先调用析构函数 2 operator delete 3 释放空间\nfree(p)怎么知道该释放多大的空间 malloc在分配空间时会多分配16个字节用来存储内存块的描述信息 在free释放空间时会左偏移16个字节读取信息\nmalloc出错会发生什么 出错原因： 一是物理内存或虚拟内存不足，即系统可提供的空闲内存无法满足程序的需求； 二是前面的程序出现了内存访问越界，导致malloc相关函数调用出现问题，这种情况下，再次使用malloc函数申请内存就可能失败 申请空间失败会返回NULL 会导致空指针\n函数重载、重写、隐藏的区别 重载（overload）：在同一作用域中，同名函数的形式参数（参数个数，类型或顺序）不同时构成函数重载\nclass A{ public: int func(int a); void func(int a,int b); void func(int a,int b,int c); int func(char* pstr,int a); } 函数返回值类型与是否构成函数重载无关，不能通过函数返回类型不同来重载函数 类的静态成员函数与普通成员函数可以形成重载 函数重载发生在同一作用域，如类成员之间的重载，全局函数之间的重载 const重载 class B{ public: void funcA(); void funcA() const;//可以通过const重载 void funcB(int a); void funcB(const int a);//不行 编译过不了 }; funcA函数是合法重载而funcB函数是非法的不能通过编译 重写/覆盖（override）：派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写 重写的特殊情况\u0026ndash;协变：当基类和派生类中该函数的返回值为父子关系的指针或者引用，返回值可以不同，这种情况称作协变 隐藏（hiding）：不同作用域中定义的同名函数构成隐藏（不要求函数返回值和参数类型相同）比如派生类成员函数隐藏与其同名的基类成员函数，类成员函数隐藏全局外部函数\n在子类中只要函数名和父类相同不是重写就是隐藏 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏\nclass Base{ public: void funA(){cout\u0026lt;\u0026lt;\u0026#34;funA()\u0026#34;\u0026lt;\u0026lt;endl;} virtual void funB(){cout\u0026lt;\u0026lt;\u0026#34;funB()\u0026#34;\u0026lt;\u0026lt;endl;} }; class Heri:public Base{ public: void funA(){cout\u0026lt;\u0026lt;\u0026#34;funA():Heri\u0026#34;\u0026lt;\u0026lt;endl;}//函数隐藏因为不是虚函数 void funA(int a){cout\u0026lt;\u0026lt;\u0026#34;funA(int a):heri\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl;}//函数隐藏参数不同 void funB(){cout\u0026lt;\u0026lt;\u0026#34;funB():heri\u0026#34;\u0026lt;\u0026lt;endl;}//函数重写 }; 三者对比\n函数重载发生在相同作用域 函数隐藏发生在不同作用域 函数覆盖就是函数重写，是函数隐藏的特例 三者 作用域 有无virtual 函数名 形参列表 返回值类型 重载 相同 可有可无 相同 不同 可同可不同 隐藏 不同 可有可无 相同 可同可不同 可同可不同 重写 不同 有 相同 相同 相同（协变） 深拷贝和浅拷贝？ c++中，浅拷贝不需要自己实现，编译器会自动生成默认的拷贝构造函数，浅拷贝新旧对象共享一块内存，任何一方的值改变都会影响另一方；深拷贝需要自己手动编写拷贝构造函数，浅拷贝新旧对象不共享内存\ntitle:浅拷贝 collapse:close c++的浅拷贝是通过拷贝构造函数实现的，如果不重载拷贝构造函数和赋值函数，编译器将以浅拷贝的方式自动生成默认的函数，也就是在拷贝时简单的赋值某个对象的指针，容易造成问题 假设A类有两个对象a和b,a.data为\u0026#34;hello\u0026#34;,b.data为\u0026#34;world\u0026#34;当将a的值赋给b时,可能有以下问题 1.b.data的内存没释放,造成内存泄露 2.b.data和a.data指向了同一块内存,a或b任何一方的值改变都会修改另一方的值 3.在对象被析构时,data被释放了两次 title:深拷贝 collapse:close 深拷贝必须显式提供拷贝构造函数和赋值运算符,而且新旧对象不共享内存,在编写拷贝构造时会开辟一个新的内存空间 什么时候会使用深拷贝? 1.一个对象以值传递的方式传入函数体 2.一个对象以值传递的方式从函数体返回 3.一个对象需要通过另一个对象进行初始化 虚函数表和虚函数表指针的创建时机？ 虚函数表：编译器编译的时候生成，发现virtual关键字修饰的函数后,虚函数表依赖类存在，不依赖对象 虚函数表存储在:代码段(常量区) 虚函数表指针：类对象构造的时候，把类的虚函数表地址赋值给vptr;类的对象前8个字节就是虚函数表的地址；在B继承A的情况下，虚函数表指针赋值过程为先调用基类构造函数，把A的虚函数表的地址赋值给vptr，再调用子类构造函数，把B的虚函数表的地址赋值给vptr;\n构造函数和析构函数能不能是虚函数？ 构造函数不可以\n因为创建一个对象时要确定对象的类型，而虚函数是在运行时确定其类型的，而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型。 虚函数对应一个虚表，可是这个虚表其实是存储在对象的内存空间的。如果构造函数是虚的，就需要通过虚表来调用，可是对象还没有实例化，也就是内存空间还没有，怎么找虚表呢？所以构造函数不能是虚函数。 析构函数可以 1、在多态当中，基类的方法被定义成虚函数，才可以通过基类指针动态调用派生类的方法，同理当我们delete 基类指针，如果基类析构函数不是虚函数，就无法动态调用到派生类的析构函数，导致派生类的对象无法析构，造成内存泄漏。反之，基类析构函数被定义成虚函数的时候，delete基类指针时，会先析构派生类对象，再析构基类对象 多态是怎么实现的？ 静态多态： 编译阶段实现，其原理是由函数重载实现，通过不同的实参调用其相应的同名函数。 动态多态： 必须通过基类的指针或者引用调用 被调用的必须是虚函数，且在派生类中实现了该虚函数的重写 （注意：只有虚函数才有重写这个概念） 动态多态的实现是依靠不同对象的虚函数指针指向的虚函数表实现的，因为里面存储了对应的虚函数 对象的指针或者引用调用虚函数时，不是编译时决议，而是运行时决议，即程序开始运行时到指定的对象虚函数表中去调用对应的虚函数，所以指向基类对象，调用是基类虚函数，指向派生类对象，调用是派生类虚函数\n1.先将基类中的虚表内容拷贝一份到派生类虚表中 2.如果派生类重写基类中某个虚函数，派生类自己的虚函数覆盖虚表中基类的虚函数 3.派生类自己新增加的虚函数按其在 派生类中的声明次序增加到派生类虚表的最后\nC和C++的区别 C++语言支持函数重载，而C不支持函数重载\nC ++编译过程 预处理阶段：引入头文件，宏替换，删除注释，生产以i为结尾的预编译文件 编译阶段：检查语法错误，没有错误将代码解释为汇编，生成以s为结尾的汇编文件 汇编阶段：将汇编代码解释为二进制的cpu指令，生成以o结尾的可重定向目标文件 链接阶段：目标文件不能直接执行，因为某个.cpp文件调用另外一个.cpp文件，为了解决这类问题，调用目标文件与被调用的目标文件连接起来，最终得到可执行程序exe，链接分为静态静态链接和动态链接 静态链接：目标文件直接拷贝到可执行文件中的链接方式，使用静态链接生成静态库，静态库对函数库的链接是在编译时期完成的 动态链接：程序运行时动态加载目标文件的链接方式 C++有几种传参方式，区别是什么？ 值传递：形参是实参的拷贝，在外部某个函数中改变形参的值并不会影响主函数内的数据 指针传递：形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作，函数传递的时候只传入一个指针占用四个字节的空间 引用传递：形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址\ninclude头文件的顺序以及双引号和尖括号的区别？ 尖括号\u0026lt;\u0026gt;的头文件是系统文件（标准库），双引号\u0026quot;\u0026ldquo;的头文件是自定义文件 使用尖括号的查找路径：编译器设置的头文件路径-\u0026gt;系统变量 使用双引号的查找路径：当前头文件目录-\u0026gt;编译器设置的头文件路径-\u0026gt;系统变量\n常量指针和指针常量的区别 int a = 1; int b = 2; int c = 3; int const *p1 = \u0026amp;b;//const在前,p1为常量指针 int *const p2 = \u0026amp;c;//*在前，p2为指针常量 p1 = \u0026amp;a;//正确，p1是常量指针，可以指向新的地址(即\u0026amp;a),即p1本身可以改变 *p1 = a;//错误，*p1是指针p1指向对象的值,不可以改变，因此不能对*p重新赋值 p2 = \u0026amp;a;//错误，p2是指针常量，本身不可以改变，因此将a的地址赋给p2是错误的 *p2 = a;//正确，p2指向的对象允许改变 常量指针p1：即指向const对象的指针，指向的地址可以改变，但其指向的内容（即对象的值）不可以改变 指针常量p2：指针本身是常量，即指向的地址本身不可以改变，但内容（即对象的值）可以改变\n声明、定义和初始化 声明：声明主要用于向程序表明变量的类型和名字，它不会为变量分配存储空间，可多次声明 定义：定义则是为变量分配存储空间，同时可以为变量指定初始值。当定义一个变量时，同时声明了它的类型。对于变量而言，定义只能有一次 初始化：初始化则是为变量赋初值\nvector插入元素，进行几次内存拷贝？ title:test collapse: open icon: triforce color: 200,50, 200 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. 内存泄漏、内存溢出和内存越界 内存泄漏：程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费 内存溢出：系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存 内存越界：程序在运行过程中访问了不在预分配的内存空间或者超出了已分配内存空间的大小\n栈区会内存泄漏吗？ 栈区一般不会发生内存泄露\n如何解决栈溢出？ 减少函数递归层次 减少局部变量数量 扩大栈的空间 空指针和野指针 野指针：指针指向的空间是不可知的、随机的、没有明确限制的 产生野指针的三种情况：\n指针未初始化 指针越界访问 指针指向的空间释放 规避野指针： 指针初始化 小心指针越界 指针指向空间释放及时置NULL 避免返回局部变量的地址 指针使用之前检查有效性 空指针：指向对象为空的指针 空指针p并不表示指向0x00000000地址的存储单元，而是表示不指向任何有效空间，虽然输出是如此 内存相关 堆和栈的区别 堆栈空间分配不同：栈由操作系统自动分配释放，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。 堆栈缓存方式不同：栈使用的是一级缓存，它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。 堆栈数据结构不同：堆类似数组结构；栈类似栈结构，先进后出。 内存管理 内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。\n栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放 堆：由new创建的内存块，一般一个new对应一个delete 自由存储区：由malloc分配的内存块，类似于堆，用free释放 全局/静态存储区：全局变量和静态变量被分配到同一块内存 常量存储区：存放常量，不允许修改 内存泄漏 常见的内存泄漏：\nnew和malloc申请资源使用后，没用delete和free释放 子类继承父类时，父类析构函数不是虚函数 windows句柄资源使用后没有释放 程序有哪些section，分别的作用？程序启动的过程？怎么判断数据分配在栈上还是堆上？ ![[Pasted image 20240321202842.png]] 从低地址到高地址，一个程序又代码段、数据段、BSS段、堆、共享区、栈等组成\n数据段：存放程序中已经初始化的全局变量和静态变量的一块内存区域 代码段：存放程序执行代码的一块内存区域，只读，代码段头部还包含一些只读的常数变量 BSS段：存放程序中未初始化的全局变量和静态变量的一块内存区域 堆区：动态申请内存使用，堆从低地址向高地址增长 共享区：位于堆和栈之间 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长，是连续的空间 关键字 const关键字 const:常量限定符，通知编译器该变量不可修改 const修饰一般常量和数组\nint const a = 100; const int a = 100; //与上面等价 int const arr [3] = {1,2,3}; const int arr [3] = {1,2,3};//与上面等价 char *p = \u0026#34;hello\u0026#34;; // 非const指针非const数据 const char *p = \u0026#34;hello\u0026#34;; // 非const指针,const数据 char * const p = \u0026#34;hello\u0026#34;; // const指针,非const数据 const char * const p = \u0026#34;hello\u0026#34;; // const指针,const数据 inline关键字（内联） 编译器在编译阶段完成对inline函数的处理，即对inline函数的调用替换为函数的本体，但这只是对编译器的建议，编译器可以这样做，也可以不这样做\n将inline函数体复制到inline函数调用处 为所用inline函数中的局部变量分配到内存空间 将Inline函数的输入参数和返回值映射到调用方法的局部变量空间中 如果inline函数有多个返回点，将其转变为inline函数代码块末尾的分支 inline通过消除调用开销来提升性能 相比宏函数的优点： 内联函数同宏函数一样在被调用处进行代码展开，省去了参数压栈、栈帧开辟和回收、结果返回等，从而提高程序运行速度 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义不会 缺点： 代码膨胀，空间换时间 inline函数无法随着函数库升级而升级 是否内联，程序员不可控，inline关键字只是对编译器的建议，决定权在编译器 - 使用函数指针调用内联函数会导致内联失败 - 如果函数代码过长或者有多重循环语句,if或witch分支语句或递归时,不宜用内联 - 类的构造函数、析构函数和虚函数不适合inline函数 explicit关键字 explicit用于修饰只有一个参数的类构造函数，表明该构造函数必须显式调用，禁止隐式转换\nC++11 左值引用和右值引用 引用：是变量的别名，不占内存空间，声明时必须初始化（不能为NULL），通过引用 修改变量值 左值：可以在等号两边，能取到地址的有名字的都是左值 变量名、返回左值引用的函数调用、前置自增/自减，解引用，赋值运算等 右值：只能在等号右边，不能取到地址没有名字的是右值 纯右值：字面值、返回非引用类型的函数调用，后置自增/自减，各种表达式 将亡值：c++11新引入的与右值引用（移动语义）相关的值类型，用来触发移动 构造或移动赋值构造，并进行资源转移，之后调用析构函数 左值引用：对左值的引用，避免对象拷贝，函数传参，函数返回值 右值引用：对右值的引用，实现移动语义，实现完美转发 const左值引用能指向右值（不能修改这个值），为此引入右值引用 右值引用通过std::move()可以指向左值 声明出来的左值引用或右值引用都是左值\nSTL ","permalink":"https://littlestonemax.github.io/posts/tech/c++%E5%9F%BA%E7%A1%80/","summary":"基础 引用和指针的区别 引用在定义时必须被初始化并且不能被初始化为NULL，指针没有要求 引用不能改变引用关系（底层用指针常量实现），指针随意 有多级指针没有多级引用 自增自减表达的含义不同。指针自加即指针向后偏移一个类型的大小，引用自增即引用的实体自加 指针用sizeof计算大小结果不同，","title":"C++基础"},{"content":"基础问题 绝对路径、当前目录、上层目录、主目录分别用什么表示 绝对路径从根目录（/）开始的完整路径 当前目录./ 上层目录../ 主目录~/ pwd\nLinux有哪些文件类型 文件类型 标识符符 介绍 普通文件 - 存储普通数据的文件，可以是文本、二进制数据、多媒体文件 目录文件 d 包含了其他文件和子目录的列表，构成了文件系统的层级结构 链接文件 l 指向其他文件或目录的引用或快捷方式，会访问到指向的目标 设备文件 b 块设备文件和字符设备文件 管道文件 p FIFO是一种特殊的文件类型，提供进程间通信的一种机制 套接字文件 s 用于进程间的网络通信(可跨计算机) ls命令什么功能，有哪些参数？ 显示指定目录下的所有文件和目录\n-a：显示所有文件及目录（包括以\u0026quot;.\u0026ldquo;开头的隐藏文） -l：以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等 -r：倒序显示文件和目录 -t：将按照修改时间排序，最新的文件在最前面 -F：在列出的文件名称后加一符号，例如可执行档则加*, 目录则加 \u0026ldquo;/\u0026rdquo; -R：递归显示目录中的所有文件和子目录 复制文件夹命令怎么写？ cp -r递归复制\ncp -r 源文件夹路径目标文件夹路径 什么命令可以对文件内容进行统计？ 在Linux中，可以使用 wc 命令对文件内容进行统计常用以下参数及其功能：\n-l：统计行数； -w：统计单词数； -c：统计字节数； -m：统计字符数。 要统计一个名为 file.txt的文件的行数、单词数和字节数，可以执行以下命令：\nwc -lwc file.txt 查看文件内容的命令有哪些？ cat 命令：这个命令可以将整个文件内容打印到终端。例如，要查看名为\u0026quot;filename\u0026quot;的文件，可以使用 cat filename 命令。\nmore 命令：这个命令能够以分页形式显示文件内容。例如，要查看名为\u0026quot;filename\u0026quot;的文件，可以使用 more filename 命令。\nless 命令：与 more 命令类似，less 命令也能够以分页形式显示文件内容，但同时它还允许用户向上或向下滚动查看文件内容。\nhead 命令：这个命令常用于查看文件的开头几行内容。例如，要查看名为\u0026quot;filename\u0026quot;的文件的前10行，可以使用 head -n 10 filename 命令。\ntail 命令：与 head 命令相对，tail 命令常用于查看文件的最后几行内容，并且会持续刷新，适合实时观察程序的日志情况。例如，要查看名为\u0026quot;filename\u0026quot;的文件的最后10行，可使用 tail -n 10 filename 命令。\n什么是inode和block？ inode是索引节点，用来存储数据属性信息，包含了文件大小、属组、归属的用户组、读写权限、文件类型、修改时间等元信息，同时还具有指向文件实体的指针功能 block是数据块，负责存储实际的数据内容，包括文件的实际文本信息等。\n硬链接和软连接的区别 介绍一下vim 文件权限修改的命令？格式是什么样的？ chmod 命令 数字格式 符号格式\n怎么查看所有进程和指定进程？ 查看所有进程：使用 ps 命令。基本语法是 ps -ef，其中 -e 选项表示显示所有进程，-f 选项表示显示完整格式的输出 查看指定进程：可以使用 ps 命令结合进程ID（PID）来查看指定进程。基本语法是 ps -p PID -ef，其中 -p PID 选项表示只显示指定PID的进程 top命令：可以实时地显示系统中各个进程的资源占用情况，包括CPU、内存等\n终止进程的命令？ kill 命令：可以向指定进程发送信号，从而终止进程 基本语法是 kill [信号] 进程ID 可以使用 kill -9 进程ID 来强制终止进程。 pkill 命令：可以根据进程名或进程所属的用户和组名来终止进程。基本语法是 pkill [选项] 进程名 可以使用 pkill firefox 来终止所有名为firefox的进程。 killall 命令：可以根据进程名来终止进程。基本语法是 killall 进程名。例如，你可以使用 killall firefox 来终止所有名为firefox的进程。 sigterm 命令：可以向指定进程发送SIGTERM信号，从而请求进程终止。基本语法是 sigterm进程ID 可以使用 sigterm 12345 来请求PID为12345的进程终止。 搜索文件的命令是什么？可以加什么选项？ find 命令：用于查找文件，它可以根据文件名、inode号等进行搜索 基本的语法是 find [路径] [选项] [表达式] find /path -type f -iname filename 会搜索指定路径下所有类型为普通文件并且文件名为filename的文件。\nfind /path -type f -iname filename 会搜索指定路径下所有类型为普通文件并且文件名为filename的文件。 查看磁盘使用空间的命令？ 在Linux系统中，可以使用以下命令查看磁盘使用空间：\ndf 命令：可以显示文件系统的总容量、已用空间、可用空间和挂载点等信息。 du 命令：可以显示指定目录或文件的占用空间大小。 lsblk 命令：可以列出所有可用块设备的信息，包括磁盘、分区等。 mount 命令：可以显示当前系统已经挂载的文件系统列表。 fdisk -l 命令：可以列出所有可用的磁盘和分区信息。 查看ip地址和接口信息的命令？ 查看IP地址：ifconfig 或 ip addr 查看接口信息：ifconfig 或 ip link\ngcc编译分哪几个步骤？ GCC编译过程主要包含以下四个步骤：\n预处理：这一阶段将源文件中的预处理指令进行处理，比如包含其他文件的头文件或者定义宏等。经过处理后，会生成一个预编译文件 编译：预编译之后，编译器将处理源代码，将其转换为汇编语言。这个阶段会生成对应的汇编代码。 汇编：汇编器将上一步得到的汇编代码转换为二进制目标文件。每一个源文件会被转换成一个单独的目标文件（.O文件） 链接：最后链接器将多个目标文件以及所需的库文件进行链接，生成最终可执行文件 动态链接库和静态链接库的区别？ MakeFile的两个常用函数和三个自动变量 Makefile中的两个常用函数是 addprefix 和 patsubst，以及三个自动变量：$(MAKEFILE_LIST)、$(wildcard) 和 $(foreach)。\naddprefix 函数用于给目标文件名添加前缀。语法：$(addprefix prefix, target)。例如： %.o: %.c gcc -c $(addprefix build/, $\u0026lt;) 这个规则表示将 .c 文件编译成 .o 文件，并使用 build/ 作为前缀。\npatsubst 函数用于替换字符串中的匹配项。语法：$(patsubst pattern, replacement, string)。例如： OBJECTS := main.o foo.o bar.o main.o: main.c gcc -c $(patsubst %.c, %.o, $\u0026lt;) 这个规则表示将 main.c 编译成 main.o，并将所有的 .c 替换为 .o。\n自动变量： $(MAKEFILE_LIST)：包含当前Makefile的文件列表。 $(wildcard)：匹配指定模式的文件列表。 $(foreach)：遍历一个列表并对每个元素执行指定的命令。 GDB有哪些指令？ GDB（GNU调试器）是一个功能强大的调试工具，它支持多种编程语言和处理器架构。以下是一些常用的GDB指令：\nbreak：设置断点。例如break main 在main函数处设置断点 run：启动程序。例如run 运行当前被调试的程序 next：执行下一行代码，但不进入函数。例如next 执行下一行代码 step：执行下一行代码，如果遇到函数调用，则进入函数内部。例如step 执行下一行代码并进入函数 continue：继续执行程序，直到遇到下一个断点或程序结束。例如continue 继续执行程序 print：打印变量的值。例如print x 打印变量x的值 watch：监视表达式的值变化。例如watch x 监视变量x的值变化 info locals：显示当前作用域内的局部变量信息。例如info locals 显示当前作用域内的局部变量信息 info args：显示当前函数的参数信息。例如info args 显示当前函数参数信息 backtrace：显示当前的栈帧信息。例如backtrace 显示当前的栈帧信息。 frame：切换到指定的栈帧。例如frame 2 切换到第2个栈帧。 list：显示当前源文件的部分或全部代码。例如list main.c:5-10 显示main.c文件的第5行到第10行代码。 source：加载指定的源文件并执行。例如source file.c 加载file.c文件并执行。 delete breakpoint：删除指定的断点。例如：delete 1 删除编号为1的断点。 help：查看GDB的帮助文档。例如help breakpoint 查看关于断点的帮助文档 如何在Linux系统中查看TCP状态 TCP的连接状态查看，在Linux中可以用netstat -napt查看 ![[Pasted image 20231226183740.png]]\n-a:列出所有端口 -at:列出所有TCP端口 -au:列出所有UDP端口 -p:显示正在使用Socket的程序识别码和程序名称 -n:显示IP地址和端口号的数字格式，不进行反向解析 top 在Linux系统中，top命令是常用的分析性能的工具，能够实时监控系统中各个进程资源占用的情况，类似于windows中任务管理器\necho echo会将输入的字符串送往标准输出\nps ","permalink":"https://littlestonemax.github.io/posts/tech/linux%E5%85%A5%E9%97%A8/","summary":"基础问题 绝对路径、当前目录、上层目录、主目录分别用什么表示 绝对路径从根目录（/）开始的完整路径 当前目录./ 上层目录../ 主目录~/ pwd Linux有哪些文件类型 文件类型 标识符符 介绍 普通文件 - 存储普通数据的文件，可以是文本、二进制数据、多媒体文件 目录文件 d 包含了其他文件和子目录的列表，","title":"Linux入门"},{"content":"关于我\n昵称: LittleStoneMax 状态: 求职中\u0026hellip; 爱好: 跑步、摄影 ","permalink":"https://littlestonemax.github.io/about/","summary":"关于我 昵称: LittleStoneMax 状态: 求职中\u0026hellip; 爱好: 跑步、摄影","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"https://littlestonemax.github.io/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://littlestonemax.github.io/posts/read/read/","summary":"","title":"Read"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Stone\u0026rsquo;s Blog 网址： https://www.littlestonemax.github.io 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"https://littlestonemax.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Stone\u0026rsquo;s Blog 网址： https://www.littlestonemax.github.io 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"}]