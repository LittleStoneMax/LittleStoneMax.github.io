---
title: "Mysql数据库"
date: 2024-03-26T19:37:37+08:00
lastmod: 2024-03-26T19:37:37+08:00
author: ["LittleStoneMax"]
keywords: 
- 
categories: # 没有分类界面可以不填写
- 
tags: # 标签
- 
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
reward: true # 打赏
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
    caption: "" #图片底部描述
    alt: ""
    relative: false
---



## **数据库基础**
### **char和varchar的区别**
| char                         | varchar                             |
| ---------------------------- | ----------------------------------- |
| 最大长度255字符              | 最大长度是65535个字节               |
| 定长不足的部分用隐藏空格填充 | varchar是不定长的                   |
| char会浪费时间               | varchar会节省空间                   |
| char查找效率高               | varchar查找效率低                   |
| 插入时可省略尾部空格         | varchar插入时不会省略，查找时会省略 |

### **varchar(10) 和 varchar(20) 的区别**
如果是存储相同长度的字符串，所占空间一样，如果涉及order by排序相关，后者消耗更多内存空间
### **drop、delete与truncate的区别**
| drop             | delete       | truncate         |
| ---------------- | ------------ | ---------------- |
| 删除表结构和数据 | 删除表中数据 | 删除表中所有数据 |
| DDL              | DML          | DDL              |
| 速度最快         | 最慢         | 其次             |
| 不可回滚         | 可回滚       | 不可回滚         |

### **UNION与UNION ALL的区别**
| UNION                          | UNION ALL                    |
| ------------------------------ | ---------------------------- |
| 将不同的记录返回到单个结果集中 | 将所有记录返回到单个结果集中 |
| 性能慢                         | 性能快                       |
| 消除重复行                     | 不消除重复行                 |

### **MySQL 的内连接、左连接、右连接有什么区别**
**内连接**：根据连接条件从多个表中查询选择数据，显示这些表中与连接条件相匹配的行，组成新的记录
分为：等值连接（连接条件为相等判断）非等值连接（连接条件为不相等判断）自连接（在一个连接查询中，涉及的两个表都是同一张表的查询，相互连接的表在物理上为同一张表，在逻辑上分为两张表）
**左外连接**：left[outer] join 显示左表全部记录，右表满足连接条件的记录
**右外连接**：right[outer] join 显示右表全部记录，左表满足连接条件的记录

### **常见的聚合函数有哪些使用聚合函数需要注意什么**

| avg   | 返回某列的平均值 |
| ----- | ---------------- |
| sum   | 返回某列值的和   |
| count | 返回某列的行数   |
| max   | 返回某列的最大值 |
| min   | 返回某列的最小值 |

注意：聚合函数会自动忽略空值，不需要手动增加条件排除NULL
聚合函数不能作为where字句后的限制条件
### **请说下你对 MySQL架构的了解**
server层：连接器，查询缓存，分析器，优化器，执行器

连接器：MYSQL基于TCP协议进行传输，连接过程需要经过TCP三次握手
存储引擎：InnoDB
### **一条 SQL 语句在数据库框架中的执行流程**
1. 连接器：建立连接，管理连接、校验用户身份；
2. 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
3. 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
4. 执行 SQL：执行 SQL 共有三个阶段：
    - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列
    - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
    - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；


![[Pasted image 20231224193353.png]]
1. **连接器**：连接器连接客户端，MySQL基于TCP协议进行传输，所以要先经过TCP三次握手，连接完成建立后，判断用户密码，获取用户权限并保存，后续操作都基于连接时保存的权限进行权限逻辑的判断
2. **查询缓存**：MySQL收到SQL语句后，会解析出第一个字段，查看是什么类型的语句，如果是查询语句（select字段），MySQL会先去查询缓存（QueryCache）里查找缓存数据，查看之前是否有执行过这一条命令，查询缓存以key-value形式保存在内存中，key为SQL查询语句,value为SQL语句查询的结果，如果查询的语句命中缓存就会直接返回value给客户端，如果没命中就要继续执行，等执行完后查询的结果就会被存入查询缓存中，对于更新频繁的表，查询缓存的命中率很低，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空，如果刚缓存了一个查询结果很大数据，还没被使用这个表就更新了，那查询缓存就被清空了，所以MySQL8.0将查询缓存删除了
3. **解析器**：
	1. 词法分析：MySQL根据出入的字符串识别出关键字
	2. 语法分析：根据词法分析的结果，语法解析器会根据语法规则判断SQL语句是否满足MySQL语法，语法不对就报错，如果没问题就构建出SQL语法树，这样方便后续获取SQL类型、表名、字段名、where条件等
4. **执行SQL**：
		每条select语句流程主要分三个阶段
	1. 预处理阶段：
		- 检查SQL查询语句中的表或字段是否存在
		- 将select \*中的\*符号扩展为表上的所有列
	2. 优化阶段：优化器负责确定SQL查询语句的执行方案，当表中有多个索引时，优化器基于成本考虑决定使用哪个索引，在查询语句钱加explain命令，就会输出这条SQL语句的执行计划，其中的key就表示会使用哪个索引，若Key为null说明没有使用索引，会全表扫描，这种查询方式效率最低
	3. 执行阶段：MySQL的执行器开始执行语句，在执行过程中会与存储引擎交互，交互以记录为单位，有三种执行方式：主键索引引擎，全表扫描，索引下推

### **数据库的三范式是什么**
第一范式：属性具有原子性不可再分解，对关系型数据库的基本要求，通过分字段实现
第二范式：唯一性和依赖性，每个表都有主键，其他字段依赖主键，通过分表实现
第三范式：直接依赖，只依赖于主键，通过分表实现
### **什么是范式和反范式，以及各自优缺点**
范式：规范化的设计数据库
优点：可以减少数据冗余  数据表更新快体积小
缺点：多表联合查询，导致性能降低更难进行索引优化
反范式：增加字段，允许冗余，以空间换时间
优点：可以减少表的关联可以更好地进行索引优化
缺点：存在数据冗余及数据维护异常  对数据的修改需要更多成本
### **limit 1000000,10加载很慢，怎么解决**
检查业务需求是否合理
id自增时可以从id>1000000开始查询
增加索引
### **一条SQL查询语句的执行顺序**
书写顺序：select distinct from join on where group by having order by limit
执行顺序：from join on where group by select distinct having order by limit
### **存储过程和自定义函数**
存储过程：一组预编译的SQL语句和流程控制语句，被命名并存储在数据库中。存储过
程可以用来封装复杂的数据库操作逻辑，并在需要时进行调用。
```sql
#创建存储过程
create procedure 存储过程名()
begin
-- 存储过程的逻辑代码
-- 可以包含SQL语句、控制结构和变量操作等
end;
#执行存储过程
call 存储过程名();
#删除存储过程
drop procedure [if exists] 存储过程名;
```
```sql
create procedure mypro()
begin
select * from emp;
select * from dept;
end;
call mypro();
drop procedure if exists mypro;
```
```sql
//使用参数
create procedure 存储过程名(
[in|out|inout] 参数名1 参数的数据类型,
[in|out|inout] 参数名2 参数的数据类型,
)
begin
-- 存储过程的逻辑代码
-- 可以包含SQL语句、控制结构和变量操作等
end;
```
参数类型：
in：输入参数，存储过程的输入值，从外部传递给存储过程，存储过程内部是只读的，不能修改它的值
out：输出参数，存储过程的返回值，存储过程可以修改它的值并将其返回
inout：输入和输出参数既可以作为输入值传递给存储过程，也可以由存储过程修改并返回
优点：
- 代码复用：存储过程可以被多个应用程序或脚本调用，实现了代码的复用
- 提高性能：MySQL将编译后的存储过程放入缓存中，如果应用程序在单个连接中多次使用存储过程，直接使用编译版本
- 减少网络流量：存储过程可以一次执行多条SQL语句，减少了与数据库的交互次数
- 安全控制：存储过程可以对数据库中的数据进行严格的访问控制和权限管理
- 数据一致性：存储过程可以实现复杂的数据操作和事务处理，确保数据的一致性和完整性

缺点：
-  创建和维护成本高：SQL是一种结构化查询语言，难以处理复杂的业务逻辑
- 开发调试复杂：需要通过特定的工具和技术进行，不方便调试
- 可移植性差：存储过程通常依赖于特定的数据库平台和版本，不同的数据库系统之间存储过程的语法和特性可能有差异，导致存储过程的可移植性差

自定义函数
```sql
#创建函数
create function 函数名([参数1 数据类型 [, 参数2 数据类型, ...]])
returns 返回值类型
begin
    函数逻辑代码
end;
#调用函数
select 函数名([参数1, 参数2...]);
#删除函数
drop function [if exists] 函数名;
```
### **游标**
cursor,使用游标可以对存储过程或函数中的查询结果进行逐行处理
创建游标后，可以使用open语句打开游标，开始执行游标指定的查询语句并生成结果集。在游标打开得到结果集后，可以使用fetch语句访问它的每一行
游标处理完后，应关闭游标，释放游标使用的内存和资源
```sql
#创建游标
declare 游标名 cursor for 查询语句;
#打开游标
open 游标名;
#读取游标数据到变量中
fetch 游标名 into 变量名1[,变量名2...];
#关闭游标
close 游标名;
```
### **触发器**
trigger,在表的插入(insert) 、更新(update)、删除(delete)操作发生时自动执行MySQL语句
创建触发器时需要给出的信息：
- 触发器名
- 在操作前还是操作后触发(before/after)
- 被什么操作触发(insert/update/delete)
- 关联的表

使用触发操作的数据：
insert：可通过new访问被插入的行，before insert可以更新new中的值（允许更改被插入的值）
delete：可通过old访问被删除的行,old中的值是只读的
update：old访问更新前的值，new访问更新后的值
## **事务**
如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功；如果其中由一条执行失败，那么所有已经执行过的代码必须回滚（撤销），回到没有执行前的状态，称为事务。简单来说，就是要么所有的SQL语句全部执行成功，要么全部失败
### **事务的四大特性**
| 事务特性 |                             含义                             |
| :------: | :----------------------------------------------------------: |
|  原子性  | 事务是工作的最小单元,整个工作单元要么全部执行成功，要么全部执行失败 |
|  一致性  | 事务执行前和执行后，数据库中数据应该保持相同状态（数据总量不变） |
|  隔离性  |          事务与事务之间不能互相影响，必须保持隔离性          |
|  持久性  |       如果事务执行成功，对数据库的操作是持久的redolog        |
### **事务提交的方式**
- 自动提交：MySQL就是自动提交的（一条DML(增删改)语句会自动提交一次事务）
- 手动提交：需要先开启事务，再提交（Oracle是默认手动提交的）
- 查看事务的默认提交方式：select@@autocommit；(1代表自动提交，默认值，0代表手动提交)
- 修改默认提交方式：set@@autocommit = 0；(1代表自动提交，0代表手动提交)
### **事务的隔离级别**
在 SQL 标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。**较低级别的隔离通常可以执行更高的并发，系统的开销也更低**
- **未提交读**：事务中的修改，没有提交也能被其他事务看到，这个级别导致很多问题，性能也没好太多，很少使用
- **提交读**：事务中的修改提交后才能被看到，也被称为不可重复，因为两次执行同样的查询，可能得到不同的结果
- **可重复读**：同一事务中多次读取同样记录的结果是一致的，该级别无法解决幻读问题，该级别是MySQL的默认隔离级别，并且**MySQL的默认隔离级别**，并且MySQL在该级别就可以很大程度上避免幻读
- **可串行化(序列化)**：强制事务串行执行，避免幻读问题，该级别会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题的，很少使用这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下才考虑采用这个级别

```Sql
#查看会话级的当前隔离级别：（会话级只对当前窗口有效）
select  @@tx_isolation;
select @@session.tx_isolation;
#查看全局级的当前隔离级别： 
select @@global.tx_isolation;
```

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :------: | :--: | :--------: | :--: |
| 未提交读 |  Y   |     Y      |  Y   |
| 已提交读 |  X   |     Y      |  Y   |
| 可重复读 |  X   |     X      |  Y   |
| 可串行化 |  X   |     X      |  X   |

## **索引**
### 哪些工作表需要创建索引
通常情况下，以下类型的工作表需要创建索引：
- 数据量较大的表：数据量较大的表查询效率较低，需要创建索引来提高查询速度。
- 经常被查询的表：经常被查询的表需要创建索引来加速查询操作。
- 进行连接操作的表：进行连接操作的表需要创建索引来提高连接效率
### **索引的分类**
| 分类方式 |                    索引                    |
| :------: | :----------------------------------------: |
| 数据结构 |        B+树索引、哈希索引、全文索引        |
| 物理存储 | 聚簇索引（主键索引）、二级索引（辅助索引） |
| 字段特性 |   主键索引、唯一索引、普通索引、前缀索引   |
| 字段个数 |                                            |
### **索引的设计原则**
- 为常作为查询条件的字段建立索引：如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度
- 为经常需要排序、分组和联合操作的字段建立索引：经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作
- 创建唯一性索引：唯一性索引的值是唯一的，可以更快的通过该索引来确定某条记录
 - 限制索引的数目：每个索引都需要占⽤用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。
- 小表不建议索引（如数量级在百万以内）：由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
- 尽量使用前缀索引：如果索引的值很长，那么查询的速度会受到影响
- 删除不再使用或者很少使用的索引
### **聚簇索引**
聚簇索引（一级索引），一种数据存储方式，将数据放在索引的叶子页，索引和数据在同一个 B+ 树上。因为无法同时把数据放在两个地方，所以一个表只有一个聚簇索引
在 InnoDB 中，这个索引是主键，如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替，也没有的话 InnoDB 会隐式定义一个主键作为聚簇索引
优点：
		可以把相关数据保存在一起
		数据访问更快，索引和数据在同一个结构中
缺点：
		插入速度严重依赖插入顺序
		更新聚簇索引引列的代价高
		插入数据或更新主键时可能面临‘页分裂’问题，当主键值要求将该行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面放该行，会导致表占用更多的磁盘空间
		非聚簇索引需要两次索引查找
### **覆盖索引**
也叫索引覆盖，查询所需要的数据都可以从索引中获取，而不用再去查询数据表中的实际数据，那么这个索引就是个覆盖索引
覆盖索引可以减少树的搜索次数，避免了回表，显著提升了查询性能
```sql
create index ename_job on emp(ename,job);
explain select ename,job from emp;
```
### **索引失效**
- 查询条件包含or，or的前后不都是索引
- 使用like查询，%在前面且没有覆盖索引
- 对索引列使用函数
- 索引列使用运算
- 索引列使用不等于（<> ! = not in）
- 出现隐式类型转换，如字符型索引使用数字匹配
- 联合索引没有使用最左匹配
- 全表扫描比索引快（数据量少时）
### **最左前缀原则**
创建多列的联合索引时，满足最左前缀原则，例如创建(a,b,c)三列的索引，实际上相当于创建了 a、(a, b)、(a,b,c)三个索引
当不需要考虑排序和分组时，将选择性最高的列放在前面。这时索引的作用只用于优化 where 条件的查找，这样设计可以最快过滤需要的行。
```sql
create index ename_job_sal on emp(ename,job,sal);
explain select * from emp where ename="smith";
explain select * from emp where ename="smith"and job="manager";
explain select * from emp where job="manager";//不符合
```
### **优化索引（使用策略）**
#### 使用前缀索引
使用前缀索引可以节约索引空间，提高索引效率，但需要平衡索引的选择性
#### 联合索引 
使用联合索引可以避免回表，实现覆盖索引，可以减少大量I/O操作，创建联合索引时，不同的列顺序会影响索引的性能，通常将选择性高的列放在最前面
#### 合适的主键索引
最好选择不会修改的列作为主键，不考虑分库分表的情况下最好使用自增主键
#### 不建立重复或不使用的索引
####  防止索引失效
- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
## **其他**
### **InnoDB 和 MyISAM 的比较**
- 事务:MylSAM不支持事务，InnoDB支持事务
- 全文索引: MylSAM支持全文索引，InnoDB 5.6之前不支持全文索引
- 关于count(): MylSAM会直接存储总行数，InnoDB则不会，需要按行扫描。意思就是对于select count(from table;如果数据量大，MylSAM会瞬间返回，而InnoDB则会一行行扫描
- 外键:MylSAM不支持外键，InnoDB支持外键
- 锁: MyISAM只支持表锁，InnoDB可以支持行锁。        
### **怎么优化MySQL**
![[Pasted image 20231218192406.png]]
### **B树和B+树**
平衡二叉树随着节点的增加，树的高度会越来越高，会增加磁盘的I/O次数，影响查询效率，从而引出了B树，B树不限制一个节点只能有2个子节点，从而降低树的高度。B树可以将节点的大小优化为磁盘块的大小，每次读取可以有效加载多个节点，B树常用于数据库库等需要高效访问磁盘的场景，**B+树是对B树的升级，B+树只有叶子节点存数据，非叶子节点只存索引。叶子节点包含所有索引，叶子节点构成一个有序链表，范围查找更快**，**由于非叶子节点只存索引，B+树比B树的非叶子节点可以存更多索引，高度更低，磁盘I/O次数更少**
![[Pasted image 20231214192001.png]]

```markmap


```
### B+树和跳表的区别

#待更新。。
